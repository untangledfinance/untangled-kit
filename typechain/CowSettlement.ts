/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export declare namespace GPv2Trade {
  export type DataStruct = {
    sellTokenIndex: BigNumberish;
    buyTokenIndex: BigNumberish;
    receiver: AddressLike;
    sellAmount: BigNumberish;
    buyAmount: BigNumberish;
    validTo: BigNumberish;
    appData: BytesLike;
    feeAmount: BigNumberish;
    flags: BigNumberish;
    executedAmount: BigNumberish;
    signature: BytesLike;
  };

  export type DataStructOutput = [
    sellTokenIndex: bigint,
    buyTokenIndex: bigint,
    receiver: string,
    sellAmount: bigint,
    buyAmount: bigint,
    validTo: bigint,
    appData: string,
    feeAmount: bigint,
    flags: bigint,
    executedAmount: bigint,
    signature: string
  ] & {
    sellTokenIndex: bigint;
    buyTokenIndex: bigint;
    receiver: string;
    sellAmount: bigint;
    buyAmount: bigint;
    validTo: bigint;
    appData: string;
    feeAmount: bigint;
    flags: bigint;
    executedAmount: bigint;
    signature: string;
  };
}

export declare namespace GPv2Interaction {
  export type DataStruct = {
    target: AddressLike;
    value: BigNumberish;
    callData: BytesLike;
  };

  export type DataStructOutput = [
    target: string,
    value: bigint,
    callData: string
  ] & { target: string; value: bigint; callData: string };
}

export declare namespace IVault {
  export type BatchSwapStepStruct = {
    poolId: BytesLike;
    assetInIndex: BigNumberish;
    assetOutIndex: BigNumberish;
    amount: BigNumberish;
    userData: BytesLike;
  };

  export type BatchSwapStepStructOutput = [
    poolId: string,
    assetInIndex: bigint,
    assetOutIndex: bigint,
    amount: bigint,
    userData: string
  ] & {
    poolId: string;
    assetInIndex: bigint;
    assetOutIndex: bigint;
    amount: bigint;
    userData: string;
  };
}

export interface CowSettlementInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "authenticator"
      | "domainSeparator"
      | "filledAmount"
      | "freeFilledAmountStorage"
      | "freePreSignatureStorage"
      | "getStorageAt"
      | "invalidateOrder"
      | "preSignature"
      | "setPreSignature"
      | "settle"
      | "simulateDelegatecall"
      | "simulateDelegatecallInternal"
      | "swap"
      | "vault"
      | "vaultRelayer"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "Interaction"
      | "OrderInvalidated"
      | "PreSignature"
      | "Settlement"
      | "Trade"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "authenticator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "domainSeparator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "filledAmount",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "freeFilledAmountStorage",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "freePreSignatureStorage",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getStorageAt",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "invalidateOrder",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "preSignature",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setPreSignature",
    values: [BytesLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "settle",
    values: [
      AddressLike[],
      BigNumberish[],
      GPv2Trade.DataStruct[],
      [
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[]
      ]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "simulateDelegatecall",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "simulateDelegatecallInternal",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "swap",
    values: [IVault.BatchSwapStepStruct[], AddressLike[], GPv2Trade.DataStruct]
  ): string;
  encodeFunctionData(functionFragment: "vault", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "vaultRelayer",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "authenticator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "domainSeparator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "filledAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freeFilledAmountStorage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freePreSignatureStorage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStorageAt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "invalidateOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "preSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPreSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "settle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "simulateDelegatecall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "simulateDelegatecallInternal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "vault", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "vaultRelayer",
    data: BytesLike
  ): Result;
}

export namespace InteractionEvent {
  export type InputTuple = [
    target: AddressLike,
    value: BigNumberish,
    selector: BytesLike
  ];
  export type OutputTuple = [target: string, value: bigint, selector: string];
  export interface OutputObject {
    target: string;
    value: bigint;
    selector: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderInvalidatedEvent {
  export type InputTuple = [owner: AddressLike, orderUid: BytesLike];
  export type OutputTuple = [owner: string, orderUid: string];
  export interface OutputObject {
    owner: string;
    orderUid: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PreSignatureEvent {
  export type InputTuple = [
    owner: AddressLike,
    orderUid: BytesLike,
    signed: boolean
  ];
  export type OutputTuple = [owner: string, orderUid: string, signed: boolean];
  export interface OutputObject {
    owner: string;
    orderUid: string;
    signed: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SettlementEvent {
  export type InputTuple = [solver: AddressLike];
  export type OutputTuple = [solver: string];
  export interface OutputObject {
    solver: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TradeEvent {
  export type InputTuple = [
    owner: AddressLike,
    sellToken: AddressLike,
    buyToken: AddressLike,
    sellAmount: BigNumberish,
    buyAmount: BigNumberish,
    feeAmount: BigNumberish,
    orderUid: BytesLike
  ];
  export type OutputTuple = [
    owner: string,
    sellToken: string,
    buyToken: string,
    sellAmount: bigint,
    buyAmount: bigint,
    feeAmount: bigint,
    orderUid: string
  ];
  export interface OutputObject {
    owner: string;
    sellToken: string;
    buyToken: string;
    sellAmount: bigint;
    buyAmount: bigint;
    feeAmount: bigint;
    orderUid: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface CowSettlement extends BaseContract {
  connect(runner?: ContractRunner | null): CowSettlement;
  waitForDeployment(): Promise<this>;

  interface: CowSettlementInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  authenticator: TypedContractMethod<[], [string], "view">;

  domainSeparator: TypedContractMethod<[], [string], "view">;

  filledAmount: TypedContractMethod<[arg0: BytesLike], [bigint], "view">;

  freeFilledAmountStorage: TypedContractMethod<
    [orderUids: BytesLike[]],
    [void],
    "nonpayable"
  >;

  freePreSignatureStorage: TypedContractMethod<
    [orderUids: BytesLike[]],
    [void],
    "nonpayable"
  >;

  getStorageAt: TypedContractMethod<
    [offset: BigNumberish, length: BigNumberish],
    [string],
    "view"
  >;

  invalidateOrder: TypedContractMethod<
    [orderUid: BytesLike],
    [void],
    "nonpayable"
  >;

  preSignature: TypedContractMethod<[arg0: BytesLike], [bigint], "view">;

  setPreSignature: TypedContractMethod<
    [orderUid: BytesLike, signed: boolean],
    [void],
    "nonpayable"
  >;

  settle: TypedContractMethod<
    [
      tokens: AddressLike[],
      clearingPrices: BigNumberish[],
      trades: GPv2Trade.DataStruct[],
      interactions: [
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[]
      ]
    ],
    [void],
    "nonpayable"
  >;

  simulateDelegatecall: TypedContractMethod<
    [targetContract: AddressLike, calldataPayload: BytesLike],
    [string],
    "nonpayable"
  >;

  simulateDelegatecallInternal: TypedContractMethod<
    [targetContract: AddressLike, calldataPayload: BytesLike],
    [string],
    "nonpayable"
  >;

  swap: TypedContractMethod<
    [
      swaps: IVault.BatchSwapStepStruct[],
      tokens: AddressLike[],
      trade: GPv2Trade.DataStruct
    ],
    [void],
    "nonpayable"
  >;

  vault: TypedContractMethod<[], [string], "view">;

  vaultRelayer: TypedContractMethod<[], [string], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "authenticator"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "domainSeparator"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "filledAmount"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "freeFilledAmountStorage"
  ): TypedContractMethod<[orderUids: BytesLike[]], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "freePreSignatureStorage"
  ): TypedContractMethod<[orderUids: BytesLike[]], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getStorageAt"
  ): TypedContractMethod<
    [offset: BigNumberish, length: BigNumberish],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "invalidateOrder"
  ): TypedContractMethod<[orderUid: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "preSignature"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "setPreSignature"
  ): TypedContractMethod<
    [orderUid: BytesLike, signed: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "settle"
  ): TypedContractMethod<
    [
      tokens: AddressLike[],
      clearingPrices: BigNumberish[],
      trades: GPv2Trade.DataStruct[],
      interactions: [
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[]
      ]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "simulateDelegatecall"
  ): TypedContractMethod<
    [targetContract: AddressLike, calldataPayload: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "simulateDelegatecallInternal"
  ): TypedContractMethod<
    [targetContract: AddressLike, calldataPayload: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "swap"
  ): TypedContractMethod<
    [
      swaps: IVault.BatchSwapStepStruct[],
      tokens: AddressLike[],
      trade: GPv2Trade.DataStruct
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "vault"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "vaultRelayer"
  ): TypedContractMethod<[], [string], "view">;

  getEvent(
    key: "Interaction"
  ): TypedContractEvent<
    InteractionEvent.InputTuple,
    InteractionEvent.OutputTuple,
    InteractionEvent.OutputObject
  >;
  getEvent(
    key: "OrderInvalidated"
  ): TypedContractEvent<
    OrderInvalidatedEvent.InputTuple,
    OrderInvalidatedEvent.OutputTuple,
    OrderInvalidatedEvent.OutputObject
  >;
  getEvent(
    key: "PreSignature"
  ): TypedContractEvent<
    PreSignatureEvent.InputTuple,
    PreSignatureEvent.OutputTuple,
    PreSignatureEvent.OutputObject
  >;
  getEvent(
    key: "Settlement"
  ): TypedContractEvent<
    SettlementEvent.InputTuple,
    SettlementEvent.OutputTuple,
    SettlementEvent.OutputObject
  >;
  getEvent(
    key: "Trade"
  ): TypedContractEvent<
    TradeEvent.InputTuple,
    TradeEvent.OutputTuple,
    TradeEvent.OutputObject
  >;

  filters: {
    "Interaction(address,uint256,bytes4)": TypedContractEvent<
      InteractionEvent.InputTuple,
      InteractionEvent.OutputTuple,
      InteractionEvent.OutputObject
    >;
    Interaction: TypedContractEvent<
      InteractionEvent.InputTuple,
      InteractionEvent.OutputTuple,
      InteractionEvent.OutputObject
    >;

    "OrderInvalidated(address,bytes)": TypedContractEvent<
      OrderInvalidatedEvent.InputTuple,
      OrderInvalidatedEvent.OutputTuple,
      OrderInvalidatedEvent.OutputObject
    >;
    OrderInvalidated: TypedContractEvent<
      OrderInvalidatedEvent.InputTuple,
      OrderInvalidatedEvent.OutputTuple,
      OrderInvalidatedEvent.OutputObject
    >;

    "PreSignature(address,bytes,bool)": TypedContractEvent<
      PreSignatureEvent.InputTuple,
      PreSignatureEvent.OutputTuple,
      PreSignatureEvent.OutputObject
    >;
    PreSignature: TypedContractEvent<
      PreSignatureEvent.InputTuple,
      PreSignatureEvent.OutputTuple,
      PreSignatureEvent.OutputObject
    >;

    "Settlement(address)": TypedContractEvent<
      SettlementEvent.InputTuple,
      SettlementEvent.OutputTuple,
      SettlementEvent.OutputObject
    >;
    Settlement: TypedContractEvent<
      SettlementEvent.InputTuple,
      SettlementEvent.OutputTuple,
      SettlementEvent.OutputObject
    >;

    "Trade(address,address,address,uint256,uint256,uint256,bytes)": TypedContractEvent<
      TradeEvent.InputTuple,
      TradeEvent.OutputTuple,
      TradeEvent.OutputObject
    >;
    Trade: TypedContractEvent<
      TradeEvent.InputTuple,
      TradeEvent.OutputTuple,
      TradeEvent.OutputObject
    >;
  };
}
